import * as v from 'validtyped';
import * as path from 'path';
import * as tf from '@tensorflow/tfjs';

import { OptimizationParameters, Optimizer } from 'optimization/Optimizer';
import { giveBack } from 'utils/fp';
import { readdir, removeRecursively, writeJson } from 'utils/files';
import { getMostRecent } from 'utils/dates';
import { minutes } from 'utils/time';
import { DatasetDescription } from 'data/DatasetDescription';
import { writeTensorToCsv, loadTensorFromCsv } from 'utils/tensorflow';
import { returnVoid } from 'utils/tsUtil';
import { History } from 'analysis/History';
import { flatten } from 'utils/flatten';

// TODO: consider making distinctions between Supervised, Unsupervised, etc. algs
// they will have different function signatures for training methods.
export abstract class Algorithm {
    protected abstract readonly name: string;
    protected readonly params: Record<string, tf.Variable<tf.Rank.R2>> = {};
    protected model: tf.Model | undefined;
    protected opts: object | undefined;
    protected state: object | undefined;
    protected optimizer: Optimizer | undefined;
    protected abstract datasetDescription: DatasetDescription;

    // --------
    // Training
    // --------
    abstract async train(X: tf.Tensor2D, Y: tf.Tensor2D, opts?: Partial<OptimizationParameters>): Promise<History>;
    abstract async predict(T: tf.Tensor2D, opts?: Partial<OptimizationParameters>): Promise<tf.Tensor2D>;

    // ----------
    // Parameters
    // ----------
    getParameters() {
        return flatten(this.opts);
    }

    // ------
    // Saving
    // ------
    /**
     * Schema matching the save state json file
     * generated by the `saveState` function.
     */
    protected static SaveSchema = v.any();
    protected async _saveState(location: string): Promise<any> { /* stub */ }

    async saveState(location = 'savedModels'): Promise<string> {
        const subfolder = path.join(location, this.name, new Date().toISOString());

        const state = {
            datasetDescription: this.datasetDescription,
            metaParameters: this.opts,
            state: this.state,
        };

        const tensorNames = Object.keys(this.params);
        const saveTasks = tensorNames.map(name => {
            const tensor = this.params[name];
            return writeTensorToCsv(path.join(subfolder, `${name}.csv`), tensor);
        });

        await Promise.all([
            writeJson(path.join(subfolder, 'state.json'), state),
            ...saveTasks,
        ]);

        if (this.model) {
            await this.model.save(`file://${path.join(subfolder, 'model')}`);
        }

        if (this.optimizer) {
            await this.optimizer.saveState(path.join(subfolder, 'optimizer'));
        }

        return this._saveState(subfolder).then(giveBack(subfolder));
    }

    // -------
    // Loading
    // -------

    protected static async findSavedState(location: string): Promise<string> {
        const algFolder = path.join(location, this.name);
        const times = await readdir(algFolder);
        const mostRecent = getMostRecent(times);

        return path.join(algFolder, mostRecent.toISOString());
    }

    protected async loadTensorsFromDisk(location: string) {
        const tensorNames = Object.keys(this.params);
        const loadTasks = tensorNames.map(async (name) => {
            const initTensor = this.params[name];
            const filepath = path.join(location, `${name}.csv`);
            const tensor = await loadTensorFromCsv(filepath, initTensor.shape);
            initTensor.assign(tensor);
        });

        return Promise.all(loadTasks).then(returnVoid);
    }

    static async fromSavedState(location: string): Promise<Algorithm> {
        throw new Error('Algorithms should implement "fromSavedState" to load back-ups');
    }

    // ----------------------
    // Backup Algorithm State
    // ----------------------

    protected backupHandler: NodeJS.Timer | undefined;
    protected activeBackup: Promise<void> | undefined;
    protected lastSaveLocation: string | undefined;
    private _alg_saveLocation: string | undefined;
    private async save(saveLocation: string) {
        if (this.activeBackup) return;
        const location = await this.saveState(saveLocation).catch();
        const tmp = this.lastSaveLocation;
        this.lastSaveLocation = location;

        if (tmp) await removeRecursively(tmp);
    }

    protected startBackup(saveLocation = 'savedModels') {
        this._alg_saveLocation = saveLocation;
        this.backupHandler = setInterval(() => {
            if (this.activeBackup) return;
            this.activeBackup = this.save(saveLocation)
                .then(() => this.activeBackup = undefined);
        }, minutes(5));
    }

    protected stopBackup() {
        if (!this._alg_saveLocation) throw new Error('Cannot stop backup if it was never started');
        const location = this._alg_saveLocation;
        // if we stop backing up while there is no back occurring, save one more time
        if (!this.activeBackup) this.save(location);
        // if we stop while a save is occurring, save once more afterwards to guarantee we get the algorithm's final state
        else this.activeBackup.then(() => this.save(location));
        clearInterval(this.backupHandler as any);
        this._alg_saveLocation = undefined;
    }
}
