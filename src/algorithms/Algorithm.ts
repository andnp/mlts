import * as v from 'validtyped';
import * as path from 'path';

import { giveBack } from 'utils/fp';
import { readdir, removeRecursively } from 'utils/files';
import { getMostRecent } from 'utils/dates';
import { minutes } from 'utils/time';

export abstract class Algorithm {
    protected abstract readonly name: string;
    /**
     * Schema matching the save state json file
     * generated by the `saveState` function.
     */
    protected static SaveSchema = v.any();
    protected abstract async _saveState(location: string): Promise<any>;

    async saveState(location = 'savedModels'): Promise<string> {
        const subfolder = path.join(location, this.name, new Date().toISOString());
        return this._saveState(subfolder).then(giveBack(subfolder));
    }

    protected static async findSavedState(location: string, name: string): Promise<string> {
        const algFolder = path.join(location, name);
        const times = await readdir(algFolder);
        const mostRecent = getMostRecent(times);

        return path.join(algFolder, mostRecent.toISOString());
    }

    // ----------------------
    // Backup Algorithm State
    // ----------------------

    protected backupHandler: NodeJS.Timer | undefined;
    protected activeBackup: Promise<void> | undefined;
    protected lastSaveLocation: string | undefined;
    protected startBackup() {
        this.backupHandler = setInterval(() => {
            if (this.activeBackup) return;
            this.activeBackup = this.saveState()
                .then(location => {
                    const tmp = this.lastSaveLocation;
                    this.lastSaveLocation = location;
                    return tmp
                        ? removeRecursively(tmp)
                        : Promise.resolve();
                })
                .then(() => this.activeBackup = undefined);
        }, minutes(5));
    }

    protected stopBackup() {
        // if we stop backing up while there is no back occurring, save one more time
        if (!this.activeBackup) this.saveState();
        // if we stop while a save is occurring, save once more afterwards to guarantee we get the algorithm's final state
        else this.activeBackup.then(() => this.saveState());
        clearInterval(this.backupHandler as any);
    }
}
